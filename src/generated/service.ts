// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.2
// source: service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire'
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientDuplexStream,
  type ClientOptions,
  type ClientUnaryCall,
  type handleBidiStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js'
import { Empty } from './google/protobuf/empty'

export const protobufPackage = 'mypackage'

export interface Processor {
  /** The URI of the Processor. */
  uri: string
  /** The processor configuration, in JSON-LD */
  config: string
  /** Processor arguments, in JSON-LD */
  arguments: string
}

export interface RunnerConfig {
  /** The URI of the Runner. */
  uri: string
  /** The runner configuration, in JSON-LD */
  config: string
  arguments: Processor[]
}

export interface Message {
  uri: string
  data?: string | undefined
  close?: number | undefined
}

export interface Request {
  name: string
}

export interface Response {
  message: string
}

export interface ChatMessage {
  user: string
  message: string
}

function createBaseProcessor(): Processor {
  return { uri: '', config: '', arguments: '' }
}

export const Processor: MessageFns<Processor> = {
  encode(
    message: Processor,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.uri !== '') {
      writer.uint32(10).string(message.uri)
    }
    if (message.config !== '') {
      writer.uint32(18).string(message.config)
    }
    if (message.arguments !== '') {
      writer.uint32(26).string(message.arguments)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Processor {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseProcessor()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.uri = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.config = reader.string()
          continue
        }
        case 3: {
          if (tag !== 26) {
            break
          }

          message.arguments = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Processor {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : '',
      config: isSet(object.config) ? globalThis.String(object.config) : '',
      arguments: isSet(object.arguments)
        ? globalThis.String(object.arguments)
        : '',
    }
  },

  toJSON(message: Processor): unknown {
    const obj: any = {}
    if (message.uri !== '') {
      obj.uri = message.uri
    }
    if (message.config !== '') {
      obj.config = message.config
    }
    if (message.arguments !== '') {
      obj.arguments = message.arguments
    }
    return obj
  },

  create<I extends Exact<DeepPartial<Processor>, I>>(base?: I): Processor {
    return Processor.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<Processor>, I>>(
    object: I,
  ): Processor {
    const message = createBaseProcessor()
    message.uri = object.uri ?? ''
    message.config = object.config ?? ''
    message.arguments = object.arguments ?? ''
    return message
  },
}

function createBaseRunnerConfig(): RunnerConfig {
  return { uri: '', config: '', arguments: [] }
}

export const RunnerConfig: MessageFns<RunnerConfig> = {
  encode(
    message: RunnerConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.uri !== '') {
      writer.uint32(10).string(message.uri)
    }
    if (message.config !== '') {
      writer.uint32(18).string(message.config)
    }
    for (const v of message.arguments) {
      Processor.encode(v!, writer.uint32(26).fork()).join()
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunnerConfig {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseRunnerConfig()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.uri = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.config = reader.string()
          continue
        }
        case 3: {
          if (tag !== 26) {
            break
          }

          message.arguments.push(Processor.decode(reader, reader.uint32()))
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): RunnerConfig {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : '',
      config: isSet(object.config) ? globalThis.String(object.config) : '',
      arguments: globalThis.Array.isArray(object?.arguments)
        ? object.arguments.map((e: any) => Processor.fromJSON(e))
        : [],
    }
  },

  toJSON(message: RunnerConfig): unknown {
    const obj: any = {}
    if (message.uri !== '') {
      obj.uri = message.uri
    }
    if (message.config !== '') {
      obj.config = message.config
    }
    if (message.arguments?.length) {
      obj.arguments = message.arguments.map((e) => Processor.toJSON(e))
    }
    return obj
  },

  create<I extends Exact<DeepPartial<RunnerConfig>, I>>(
    base?: I,
  ): RunnerConfig {
    return RunnerConfig.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<RunnerConfig>, I>>(
    object: I,
  ): RunnerConfig {
    const message = createBaseRunnerConfig()
    message.uri = object.uri ?? ''
    message.config = object.config ?? ''
    message.arguments =
      object.arguments?.map((e) => Processor.fromPartial(e)) || []
    return message
  },
}

function createBaseMessage(): Message {
  return { uri: '', data: undefined, close: undefined }
}

export const Message: MessageFns<Message> = {
  encode(
    message: Message,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.uri !== '') {
      writer.uint32(10).string(message.uri)
    }
    if (message.data !== undefined) {
      writer.uint32(18).string(message.data)
    }
    if (message.close !== undefined) {
      writer.uint32(24).int64(message.close)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseMessage()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.uri = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.data = reader.string()
          continue
        }
        case 3: {
          if (tag !== 24) {
            break
          }

          message.close = longToNumber(reader.int64())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Message {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : '',
      data: isSet(object.data) ? globalThis.String(object.data) : undefined,
      close: isSet(object.close) ? globalThis.Number(object.close) : undefined,
    }
  },

  toJSON(message: Message): unknown {
    const obj: any = {}
    if (message.uri !== '') {
      obj.uri = message.uri
    }
    if (message.data !== undefined) {
      obj.data = message.data
    }
    if (message.close !== undefined) {
      obj.close = Math.round(message.close)
    }
    return obj
  },

  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {
    return Message.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {
    const message = createBaseMessage()
    message.uri = object.uri ?? ''
    message.data = object.data ?? undefined
    message.close = object.close ?? undefined
    return message
  },
}

function createBaseRequest(): Request {
  return { name: '' }
}

export const Request: MessageFns<Request> = {
  encode(
    message: Request,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.name !== '') {
      writer.uint32(10).string(message.name)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Request {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseRequest()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.name = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Request {
    return { name: isSet(object.name) ? globalThis.String(object.name) : '' }
  },

  toJSON(message: Request): unknown {
    const obj: any = {}
    if (message.name !== '') {
      obj.name = message.name
    }
    return obj
  },

  create<I extends Exact<DeepPartial<Request>, I>>(base?: I): Request {
    return Request.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<Request>, I>>(object: I): Request {
    const message = createBaseRequest()
    message.name = object.name ?? ''
    return message
  },
}

function createBaseResponse(): Response {
  return { message: '' }
}

export const Response: MessageFns<Response> = {
  encode(
    message: Response,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.message !== '') {
      writer.uint32(10).string(message.message)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Response {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseResponse()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.message = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Response {
    return {
      message: isSet(object.message) ? globalThis.String(object.message) : '',
    }
  },

  toJSON(message: Response): unknown {
    const obj: any = {}
    if (message.message !== '') {
      obj.message = message.message
    }
    return obj
  },

  create<I extends Exact<DeepPartial<Response>, I>>(base?: I): Response {
    return Response.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<Response>, I>>(object: I): Response {
    const message = createBaseResponse()
    message.message = object.message ?? ''
    return message
  },
}

function createBaseChatMessage(): ChatMessage {
  return { user: '', message: '' }
}

export const ChatMessage: MessageFns<ChatMessage> = {
  encode(
    message: ChatMessage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.user !== '') {
      writer.uint32(10).string(message.user)
    }
    if (message.message !== '') {
      writer.uint32(18).string(message.message)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChatMessage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseChatMessage()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.user = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.message = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): ChatMessage {
    return {
      user: isSet(object.user) ? globalThis.String(object.user) : '',
      message: isSet(object.message) ? globalThis.String(object.message) : '',
    }
  },

  toJSON(message: ChatMessage): unknown {
    const obj: any = {}
    if (message.user !== '') {
      obj.user = message.user
    }
    if (message.message !== '') {
      obj.message = message.message
    }
    return obj
  },

  create<I extends Exact<DeepPartial<ChatMessage>, I>>(base?: I): ChatMessage {
    return ChatMessage.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<ChatMessage>, I>>(
    object: I,
  ): ChatMessage {
    const message = createBaseChatMessage()
    message.user = object.user ?? ''
    message.message = object.message ?? ''
    return message
  },
}

export type RunnerService = typeof RunnerService
export const RunnerService = {
  init: {
    path: '/mypackage.Runner/init',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Processor) =>
      Buffer.from(Processor.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Processor.decode(value),
    responseSerialize: (value: Empty) =>
      Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Empty.decode(value),
  },
  start: {
    path: '/mypackage.Runner/start',
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: Message) =>
      Buffer.from(Message.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Message.decode(value),
    responseSerialize: (value: Message) =>
      Buffer.from(Message.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Message.decode(value),
  },
} as const

export interface RunnerServer extends UntypedServiceImplementation {
  init: handleUnaryCall<Processor, Empty>
  start: handleBidiStreamingCall<Message, Message>
}

export interface RunnerClient extends Client {
  init(
    request: Processor,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall
  init(
    request: Processor,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall
  init(
    request: Processor,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientUnaryCall
  start(): ClientDuplexStream<Message, Message>
  start(options: Partial<CallOptions>): ClientDuplexStream<Message, Message>
  start(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<Message, Message>
}

export const RunnerClient = makeGenericClientConstructor(
  RunnerService,
  'mypackage.Runner',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): RunnerClient
  service: typeof RunnerService
  serviceName: string
}

export type MyServiceService = typeof MyServiceService
export const MyServiceService = {
  sayHello: {
    path: '/mypackage.MyService/SayHello',
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: Request) =>
      Buffer.from(Request.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Request.decode(value),
    responseSerialize: (value: Response) =>
      Buffer.from(Response.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Response.decode(value),
  },
  chatStream: {
    path: '/mypackage.MyService/ChatStream',
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: ChatMessage) =>
      Buffer.from(ChatMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ChatMessage.decode(value),
    responseSerialize: (value: ChatMessage) =>
      Buffer.from(ChatMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ChatMessage.decode(value),
  },
} as const

export interface MyServiceServer extends UntypedServiceImplementation {
  sayHello: handleUnaryCall<Request, Response>
  chatStream: handleBidiStreamingCall<ChatMessage, ChatMessage>
}

export interface MyServiceClient extends Client {
  sayHello(
    request: Request,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall
  sayHello(
    request: Request,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall
  sayHello(
    request: Request,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Response) => void,
  ): ClientUnaryCall
  chatStream(): ClientDuplexStream<ChatMessage, ChatMessage>
  chatStream(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<ChatMessage, ChatMessage>
  chatStream(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<ChatMessage, ChatMessage>
}

export const MyServiceClient = makeGenericClientConstructor(
  MyServiceService,
  'mypackage.MyService',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): MyServiceClient
  service: typeof MyServiceService
  serviceName: string
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>

type KeysOfUnion<T> = T extends T ? keyof T : never
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never
    }

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString())
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER')
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error('Value is smaller than Number.MIN_SAFE_INTEGER')
  }
  return num
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter
  decode(input: BinaryReader | Uint8Array, length?: number): T
  fromJSON(object: any): T
  toJSON(message: T): unknown
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T
}
