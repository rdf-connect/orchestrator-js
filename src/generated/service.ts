// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.2
// source: service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire'
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientDuplexStream,
  type ClientOptions,
  type ClientReadableStream,
  type ClientWritableStream,
  type handleBidiStreamingCall,
  type handleClientStreamingCall,
  type handleServerStreamingCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js'
import { Empty } from './google/protobuf/empty'

export const protobufPackage = 'mypackage'

export interface Error {
  cause: string
}

export interface Identify {
  uri: string
}

export interface Processor {
  /** The URI of the Processor. */
  uri: string
  /** The processor configuration, in JSON-LD */
  config: string
  /** Processor arguments, in JSON-LD */
  arguments: string
}

/** Tells the orchestrator that the processor is initialized */
export interface ProcessorInit {
  /** The URI of the Processor. */
  uri: string
  error?: Error | undefined
}

export interface Close {
  channel: string
}

export interface Message {
  channel: string
  data: Uint8Array
}

export interface StreamMessage {
  id: Id | undefined
  channel: string
}

/** All possible messages that runners handle */
export interface RunnerMessage {
  proc?: Processor | undefined
  start?: Empty | undefined
  msg?: Message | undefined
  close?: Close | undefined
  streamMsg?: StreamMessage | undefined
}

export interface OrchestratorMessage {
  init?: ProcessorInit | undefined
  msg?: Message | undefined
  close?: Close | undefined
  identify?: Identify | undefined
  streamMsg?: StreamMessage | undefined
}

export interface Id {
  id: number
}

export interface DataChunk {
  data: Uint8Array
}

export interface LogMessage {
  level: string
  msg: string
  entities: string[]
  aliases: string[]
}

function createBaseError(): Error {
  return { cause: '' }
}

export const Error: MessageFns<Error> = {
  encode(
    message: Error,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.cause !== '') {
      writer.uint32(10).string(message.cause)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseError()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.cause = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Error {
    return { cause: isSet(object.cause) ? globalThis.String(object.cause) : '' }
  },

  toJSON(message: Error): unknown {
    const obj: any = {}
    if (message.cause !== '') {
      obj.cause = message.cause
    }
    return obj
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError()
    message.cause = object.cause ?? ''
    return message
  },
}

function createBaseIdentify(): Identify {
  return { uri: '' }
}

export const Identify: MessageFns<Identify> = {
  encode(
    message: Identify,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.uri !== '') {
      writer.uint32(10).string(message.uri)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Identify {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseIdentify()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.uri = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Identify {
    return { uri: isSet(object.uri) ? globalThis.String(object.uri) : '' }
  },

  toJSON(message: Identify): unknown {
    const obj: any = {}
    if (message.uri !== '') {
      obj.uri = message.uri
    }
    return obj
  },

  create<I extends Exact<DeepPartial<Identify>, I>>(base?: I): Identify {
    return Identify.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<Identify>, I>>(object: I): Identify {
    const message = createBaseIdentify()
    message.uri = object.uri ?? ''
    return message
  },
}

function createBaseProcessor(): Processor {
  return { uri: '', config: '', arguments: '' }
}

export const Processor: MessageFns<Processor> = {
  encode(
    message: Processor,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.uri !== '') {
      writer.uint32(10).string(message.uri)
    }
    if (message.config !== '') {
      writer.uint32(18).string(message.config)
    }
    if (message.arguments !== '') {
      writer.uint32(26).string(message.arguments)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Processor {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseProcessor()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.uri = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.config = reader.string()
          continue
        }
        case 3: {
          if (tag !== 26) {
            break
          }

          message.arguments = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Processor {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : '',
      config: isSet(object.config) ? globalThis.String(object.config) : '',
      arguments: isSet(object.arguments)
        ? globalThis.String(object.arguments)
        : '',
    }
  },

  toJSON(message: Processor): unknown {
    const obj: any = {}
    if (message.uri !== '') {
      obj.uri = message.uri
    }
    if (message.config !== '') {
      obj.config = message.config
    }
    if (message.arguments !== '') {
      obj.arguments = message.arguments
    }
    return obj
  },

  create<I extends Exact<DeepPartial<Processor>, I>>(base?: I): Processor {
    return Processor.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<Processor>, I>>(
    object: I,
  ): Processor {
    const message = createBaseProcessor()
    message.uri = object.uri ?? ''
    message.config = object.config ?? ''
    message.arguments = object.arguments ?? ''
    return message
  },
}

function createBaseProcessorInit(): ProcessorInit {
  return { uri: '', error: undefined }
}

export const ProcessorInit: MessageFns<ProcessorInit> = {
  encode(
    message: ProcessorInit,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.uri !== '') {
      writer.uint32(10).string(message.uri)
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join()
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorInit {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseProcessorInit()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.uri = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.error = Error.decode(reader, reader.uint32())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): ProcessorInit {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : '',
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    }
  },

  toJSON(message: ProcessorInit): unknown {
    const obj: any = {}
    if (message.uri !== '') {
      obj.uri = message.uri
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error)
    }
    return obj
  },

  create<I extends Exact<DeepPartial<ProcessorInit>, I>>(
    base?: I,
  ): ProcessorInit {
    return ProcessorInit.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorInit>, I>>(
    object: I,
  ): ProcessorInit {
    const message = createBaseProcessorInit()
    message.uri = object.uri ?? ''
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined
    return message
  },
}

function createBaseClose(): Close {
  return { channel: '' }
}

export const Close: MessageFns<Close> = {
  encode(
    message: Close,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.channel !== '') {
      writer.uint32(10).string(message.channel)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Close {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseClose()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.channel = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Close {
    return {
      channel: isSet(object.channel) ? globalThis.String(object.channel) : '',
    }
  },

  toJSON(message: Close): unknown {
    const obj: any = {}
    if (message.channel !== '') {
      obj.channel = message.channel
    }
    return obj
  },

  create<I extends Exact<DeepPartial<Close>, I>>(base?: I): Close {
    return Close.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<Close>, I>>(object: I): Close {
    const message = createBaseClose()
    message.channel = object.channel ?? ''
    return message
  },
}

function createBaseMessage(): Message {
  return { channel: '', data: new Uint8Array(0) }
}

export const Message: MessageFns<Message> = {
  encode(
    message: Message,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.channel !== '') {
      writer.uint32(10).string(message.channel)
    }
    if (message.data.length !== 0) {
      writer.uint32(18).bytes(message.data)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseMessage()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.channel = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.data = reader.bytes()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Message {
    return {
      channel: isSet(object.channel) ? globalThis.String(object.channel) : '',
      data: isSet(object.data)
        ? bytesFromBase64(object.data)
        : new Uint8Array(0),
    }
  },

  toJSON(message: Message): unknown {
    const obj: any = {}
    if (message.channel !== '') {
      obj.channel = message.channel
    }
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data)
    }
    return obj
  },

  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {
    return Message.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {
    const message = createBaseMessage()
    message.channel = object.channel ?? ''
    message.data = object.data ?? new Uint8Array(0)
    return message
  },
}

function createBaseStreamMessage(): StreamMessage {
  return { id: undefined, channel: '' }
}

export const StreamMessage: MessageFns<StreamMessage> = {
  encode(
    message: StreamMessage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.id !== undefined) {
      Id.encode(message.id, writer.uint32(10).fork()).join()
    }
    if (message.channel !== '') {
      writer.uint32(18).string(message.channel)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StreamMessage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseStreamMessage()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.id = Id.decode(reader, reader.uint32())
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.channel = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): StreamMessage {
    return {
      id: isSet(object.id) ? Id.fromJSON(object.id) : undefined,
      channel: isSet(object.channel) ? globalThis.String(object.channel) : '',
    }
  },

  toJSON(message: StreamMessage): unknown {
    const obj: any = {}
    if (message.id !== undefined) {
      obj.id = Id.toJSON(message.id)
    }
    if (message.channel !== '') {
      obj.channel = message.channel
    }
    return obj
  },

  create<I extends Exact<DeepPartial<StreamMessage>, I>>(
    base?: I,
  ): StreamMessage {
    return StreamMessage.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<StreamMessage>, I>>(
    object: I,
  ): StreamMessage {
    const message = createBaseStreamMessage()
    message.id =
      object.id !== undefined && object.id !== null
        ? Id.fromPartial(object.id)
        : undefined
    message.channel = object.channel ?? ''
    return message
  },
}

function createBaseRunnerMessage(): RunnerMessage {
  return {
    proc: undefined,
    start: undefined,
    msg: undefined,
    close: undefined,
    streamMsg: undefined,
  }
}

export const RunnerMessage: MessageFns<RunnerMessage> = {
  encode(
    message: RunnerMessage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.proc !== undefined) {
      Processor.encode(message.proc, writer.uint32(10).fork()).join()
    }
    if (message.start !== undefined) {
      Empty.encode(message.start, writer.uint32(18).fork()).join()
    }
    if (message.msg !== undefined) {
      Message.encode(message.msg, writer.uint32(26).fork()).join()
    }
    if (message.close !== undefined) {
      Close.encode(message.close, writer.uint32(34).fork()).join()
    }
    if (message.streamMsg !== undefined) {
      StreamMessage.encode(message.streamMsg, writer.uint32(42).fork()).join()
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunnerMessage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseRunnerMessage()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.proc = Processor.decode(reader, reader.uint32())
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.start = Empty.decode(reader, reader.uint32())
          continue
        }
        case 3: {
          if (tag !== 26) {
            break
          }

          message.msg = Message.decode(reader, reader.uint32())
          continue
        }
        case 4: {
          if (tag !== 34) {
            break
          }

          message.close = Close.decode(reader, reader.uint32())
          continue
        }
        case 5: {
          if (tag !== 42) {
            break
          }

          message.streamMsg = StreamMessage.decode(reader, reader.uint32())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): RunnerMessage {
    return {
      proc: isSet(object.proc) ? Processor.fromJSON(object.proc) : undefined,
      start: isSet(object.start) ? Empty.fromJSON(object.start) : undefined,
      msg: isSet(object.msg) ? Message.fromJSON(object.msg) : undefined,
      close: isSet(object.close) ? Close.fromJSON(object.close) : undefined,
      streamMsg: isSet(object.streamMsg)
        ? StreamMessage.fromJSON(object.streamMsg)
        : undefined,
    }
  },

  toJSON(message: RunnerMessage): unknown {
    const obj: any = {}
    if (message.proc !== undefined) {
      obj.proc = Processor.toJSON(message.proc)
    }
    if (message.start !== undefined) {
      obj.start = Empty.toJSON(message.start)
    }
    if (message.msg !== undefined) {
      obj.msg = Message.toJSON(message.msg)
    }
    if (message.close !== undefined) {
      obj.close = Close.toJSON(message.close)
    }
    if (message.streamMsg !== undefined) {
      obj.streamMsg = StreamMessage.toJSON(message.streamMsg)
    }
    return obj
  },

  create<I extends Exact<DeepPartial<RunnerMessage>, I>>(
    base?: I,
  ): RunnerMessage {
    return RunnerMessage.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<RunnerMessage>, I>>(
    object: I,
  ): RunnerMessage {
    const message = createBaseRunnerMessage()
    message.proc =
      object.proc !== undefined && object.proc !== null
        ? Processor.fromPartial(object.proc)
        : undefined
    message.start =
      object.start !== undefined && object.start !== null
        ? Empty.fromPartial(object.start)
        : undefined
    message.msg =
      object.msg !== undefined && object.msg !== null
        ? Message.fromPartial(object.msg)
        : undefined
    message.close =
      object.close !== undefined && object.close !== null
        ? Close.fromPartial(object.close)
        : undefined
    message.streamMsg =
      object.streamMsg !== undefined && object.streamMsg !== null
        ? StreamMessage.fromPartial(object.streamMsg)
        : undefined
    return message
  },
}

function createBaseOrchestratorMessage(): OrchestratorMessage {
  return {
    init: undefined,
    msg: undefined,
    close: undefined,
    identify: undefined,
    streamMsg: undefined,
  }
}

export const OrchestratorMessage: MessageFns<OrchestratorMessage> = {
  encode(
    message: OrchestratorMessage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.init !== undefined) {
      ProcessorInit.encode(message.init, writer.uint32(10).fork()).join()
    }
    if (message.msg !== undefined) {
      Message.encode(message.msg, writer.uint32(18).fork()).join()
    }
    if (message.close !== undefined) {
      Close.encode(message.close, writer.uint32(26).fork()).join()
    }
    if (message.identify !== undefined) {
      Identify.encode(message.identify, writer.uint32(34).fork()).join()
    }
    if (message.streamMsg !== undefined) {
      StreamMessage.encode(message.streamMsg, writer.uint32(42).fork()).join()
    }
    return writer
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OrchestratorMessage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseOrchestratorMessage()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.init = ProcessorInit.decode(reader, reader.uint32())
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.msg = Message.decode(reader, reader.uint32())
          continue
        }
        case 3: {
          if (tag !== 26) {
            break
          }

          message.close = Close.decode(reader, reader.uint32())
          continue
        }
        case 4: {
          if (tag !== 34) {
            break
          }

          message.identify = Identify.decode(reader, reader.uint32())
          continue
        }
        case 5: {
          if (tag !== 42) {
            break
          }

          message.streamMsg = StreamMessage.decode(reader, reader.uint32())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): OrchestratorMessage {
    return {
      init: isSet(object.init)
        ? ProcessorInit.fromJSON(object.init)
        : undefined,
      msg: isSet(object.msg) ? Message.fromJSON(object.msg) : undefined,
      close: isSet(object.close) ? Close.fromJSON(object.close) : undefined,
      identify: isSet(object.identify)
        ? Identify.fromJSON(object.identify)
        : undefined,
      streamMsg: isSet(object.streamMsg)
        ? StreamMessage.fromJSON(object.streamMsg)
        : undefined,
    }
  },

  toJSON(message: OrchestratorMessage): unknown {
    const obj: any = {}
    if (message.init !== undefined) {
      obj.init = ProcessorInit.toJSON(message.init)
    }
    if (message.msg !== undefined) {
      obj.msg = Message.toJSON(message.msg)
    }
    if (message.close !== undefined) {
      obj.close = Close.toJSON(message.close)
    }
    if (message.identify !== undefined) {
      obj.identify = Identify.toJSON(message.identify)
    }
    if (message.streamMsg !== undefined) {
      obj.streamMsg = StreamMessage.toJSON(message.streamMsg)
    }
    return obj
  },

  create<I extends Exact<DeepPartial<OrchestratorMessage>, I>>(
    base?: I,
  ): OrchestratorMessage {
    return OrchestratorMessage.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<OrchestratorMessage>, I>>(
    object: I,
  ): OrchestratorMessage {
    const message = createBaseOrchestratorMessage()
    message.init =
      object.init !== undefined && object.init !== null
        ? ProcessorInit.fromPartial(object.init)
        : undefined
    message.msg =
      object.msg !== undefined && object.msg !== null
        ? Message.fromPartial(object.msg)
        : undefined
    message.close =
      object.close !== undefined && object.close !== null
        ? Close.fromPartial(object.close)
        : undefined
    message.identify =
      object.identify !== undefined && object.identify !== null
        ? Identify.fromPartial(object.identify)
        : undefined
    message.streamMsg =
      object.streamMsg !== undefined && object.streamMsg !== null
        ? StreamMessage.fromPartial(object.streamMsg)
        : undefined
    return message
  },
}

function createBaseId(): Id {
  return { id: 0 }
}

export const Id: MessageFns<Id> = {
  encode(message: Id, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).uint64(message.id)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Id {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseId()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break
          }

          message.id = longToNumber(reader.uint64())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Id {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 }
  },

  toJSON(message: Id): unknown {
    const obj: any = {}
    if (message.id !== 0) {
      obj.id = Math.round(message.id)
    }
    return obj
  },

  create<I extends Exact<DeepPartial<Id>, I>>(base?: I): Id {
    return Id.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<Id>, I>>(object: I): Id {
    const message = createBaseId()
    message.id = object.id ?? 0
    return message
  },
}

function createBaseDataChunk(): DataChunk {
  return { data: new Uint8Array(0) }
}

export const DataChunk: MessageFns<DataChunk> = {
  encode(
    message: DataChunk,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.data.length !== 0) {
      writer.uint32(10).bytes(message.data)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataChunk {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseDataChunk()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.data = reader.bytes()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): DataChunk {
    return {
      data: isSet(object.data)
        ? bytesFromBase64(object.data)
        : new Uint8Array(0),
    }
  },

  toJSON(message: DataChunk): unknown {
    const obj: any = {}
    if (message.data.length !== 0) {
      obj.data = base64FromBytes(message.data)
    }
    return obj
  },

  create<I extends Exact<DeepPartial<DataChunk>, I>>(base?: I): DataChunk {
    return DataChunk.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<DataChunk>, I>>(
    object: I,
  ): DataChunk {
    const message = createBaseDataChunk()
    message.data = object.data ?? new Uint8Array(0)
    return message
  },
}

function createBaseLogMessage(): LogMessage {
  return { level: '', msg: '', entities: [], aliases: [] }
}

export const LogMessage: MessageFns<LogMessage> = {
  encode(
    message: LogMessage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.level !== '') {
      writer.uint32(10).string(message.level)
    }
    if (message.msg !== '') {
      writer.uint32(18).string(message.msg)
    }
    for (const v of message.entities) {
      writer.uint32(26).string(v!)
    }
    for (const v of message.aliases) {
      writer.uint32(34).string(v!)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LogMessage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseLogMessage()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.level = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.msg = reader.string()
          continue
        }
        case 3: {
          if (tag !== 26) {
            break
          }

          message.entities.push(reader.string())
          continue
        }
        case 4: {
          if (tag !== 34) {
            break
          }

          message.aliases.push(reader.string())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): LogMessage {
    return {
      level: isSet(object.level) ? globalThis.String(object.level) : '',
      msg: isSet(object.msg) ? globalThis.String(object.msg) : '',
      entities: globalThis.Array.isArray(object?.entities)
        ? object.entities.map((e: any) => globalThis.String(e))
        : [],
      aliases: globalThis.Array.isArray(object?.aliases)
        ? object.aliases.map((e: any) => globalThis.String(e))
        : [],
    }
  },

  toJSON(message: LogMessage): unknown {
    const obj: any = {}
    if (message.level !== '') {
      obj.level = message.level
    }
    if (message.msg !== '') {
      obj.msg = message.msg
    }
    if (message.entities?.length) {
      obj.entities = message.entities
    }
    if (message.aliases?.length) {
      obj.aliases = message.aliases
    }
    return obj
  },

  create<I extends Exact<DeepPartial<LogMessage>, I>>(base?: I): LogMessage {
    return LogMessage.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<LogMessage>, I>>(
    object: I,
  ): LogMessage {
    const message = createBaseLogMessage()
    message.level = object.level ?? ''
    message.msg = object.msg ?? ''
    message.entities = object.entities?.map((e) => e) || []
    message.aliases = object.aliases?.map((e) => e) || []
    return message
  },
}

export type RunnerService = typeof RunnerService
export const RunnerService = {
  connect: {
    path: '/mypackage.Runner/connect',
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: OrchestratorMessage) =>
      Buffer.from(OrchestratorMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => OrchestratorMessage.decode(value),
    responseSerialize: (value: RunnerMessage) =>
      Buffer.from(RunnerMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RunnerMessage.decode(value),
  },
  sendStreamMessage: {
    path: '/mypackage.Runner/sendStreamMessage',
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: DataChunk) =>
      Buffer.from(DataChunk.encode(value).finish()),
    requestDeserialize: (value: Buffer) => DataChunk.decode(value),
    responseSerialize: (value: Id) => Buffer.from(Id.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Id.decode(value),
  },
  receiveStreamMessage: {
    path: '/mypackage.Runner/receiveStreamMessage',
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: Id) => Buffer.from(Id.encode(value).finish()),
    requestDeserialize: (value: Buffer) => Id.decode(value),
    responseSerialize: (value: DataChunk) =>
      Buffer.from(DataChunk.encode(value).finish()),
    responseDeserialize: (value: Buffer) => DataChunk.decode(value),
  },
  logStream: {
    path: '/mypackage.Runner/logStream',
    requestStream: true,
    responseStream: false,
    requestSerialize: (value: LogMessage) =>
      Buffer.from(LogMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => LogMessage.decode(value),
    responseSerialize: (value: Empty) =>
      Buffer.from(Empty.encode(value).finish()),
    responseDeserialize: (value: Buffer) => Empty.decode(value),
  },
} as const

export interface RunnerServer extends UntypedServiceImplementation {
  connect: handleBidiStreamingCall<OrchestratorMessage, RunnerMessage>
  sendStreamMessage: handleBidiStreamingCall<DataChunk, Id>
  receiveStreamMessage: handleServerStreamingCall<Id, DataChunk>
  logStream: handleClientStreamingCall<LogMessage, Empty>
}

export interface RunnerClient extends Client {
  connect(): ClientDuplexStream<OrchestratorMessage, RunnerMessage>
  connect(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<OrchestratorMessage, RunnerMessage>
  connect(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<OrchestratorMessage, RunnerMessage>
  sendStreamMessage(): ClientDuplexStream<DataChunk, Id>
  sendStreamMessage(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<DataChunk, Id>
  sendStreamMessage(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<DataChunk, Id>
  receiveStreamMessage(
    request: Id,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<DataChunk>
  receiveStreamMessage(
    request: Id,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<DataChunk>
  logStream(
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientWritableStream<LogMessage>
  logStream(
    metadata: Metadata,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientWritableStream<LogMessage>
  logStream(
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientWritableStream<LogMessage>
  logStream(
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: Empty) => void,
  ): ClientWritableStream<LogMessage>
}

export const RunnerClient = makeGenericClientConstructor(
  RunnerService,
  'mypackage.Runner',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): RunnerClient
  service: typeof RunnerService
  serviceName: string
}

function bytesFromBase64(b64: string): Uint8Array {
  if ((globalThis as any).Buffer) {
    return Uint8Array.from(globalThis.Buffer.from(b64, 'base64'))
  } else {
    const bin = globalThis.atob(b64)
    const arr = new Uint8Array(bin.length)
    for (let i = 0; i < bin.length; ++i) {
      arr[i] = bin.charCodeAt(i)
    }
    return arr
  }
}

function base64FromBytes(arr: Uint8Array): string {
  if ((globalThis as any).Buffer) {
    return globalThis.Buffer.from(arr).toString('base64')
  } else {
    const bin: string[] = []
    arr.forEach((byte) => {
      bin.push(globalThis.String.fromCharCode(byte))
    })
    return globalThis.btoa(bin.join(''))
  }
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>

type KeysOfUnion<T> = T extends T ? keyof T : never
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never
    }

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString())
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error('Value is larger than Number.MAX_SAFE_INTEGER')
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error('Value is smaller than Number.MIN_SAFE_INTEGER')
  }
  return num
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter
  decode(input: BinaryReader | Uint8Array, length?: number): T
  fromJSON(object: any): T
  toJSON(message: T): unknown
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T
}
