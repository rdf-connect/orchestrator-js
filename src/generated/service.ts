// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.6.1
//   protoc               v5.29.2
// source: service.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from '@bufbuild/protobuf/wire'
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientDuplexStream,
  type ClientOptions,
  type handleBidiStreamingCall,
  makeGenericClientConstructor,
  Metadata,
  type UntypedServiceImplementation,
} from '@grpc/grpc-js'
import { Empty } from './google/protobuf/empty'

export const protobufPackage = 'mypackage'

export interface Error {
  cause: string
}

export interface Identify {
  uri: string
}

export interface Processor {
  /** The URI of the Processor. */
  uri: string
  /** The processor configuration, in JSON-LD */
  config: string
  /** Processor arguments, in JSON-LD */
  arguments: string
}

/** Tells the orchestrator that the processor is initialized */
export interface ProcessorInit {
  /** The URI of the Processor. */
  uri: string
  error?: Error | undefined
}

export interface Close {
  channel: string
}

export interface Message {
  channel: string
  data: string
}

/** All possible messages that runners handle */
export interface RunnerMessage {
  proc?: Processor | undefined
  start?: Empty | undefined
  msg?: Message | undefined
  close?: Close | undefined
}

export interface OrchestratorMessage {
  init?: ProcessorInit | undefined
  msg?: Message | undefined
  close?: Close | undefined
  identify?: Identify | undefined
}

function createBaseError(): Error {
  return { cause: '' }
}

export const Error: MessageFns<Error> = {
  encode(
    message: Error,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.cause !== '') {
      writer.uint32(10).string(message.cause)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Error {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseError()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.cause = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Error {
    return { cause: isSet(object.cause) ? globalThis.String(object.cause) : '' }
  },

  toJSON(message: Error): unknown {
    const obj: any = {}
    if (message.cause !== '') {
      obj.cause = message.cause
    }
    return obj
  },

  create<I extends Exact<DeepPartial<Error>, I>>(base?: I): Error {
    return Error.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<Error>, I>>(object: I): Error {
    const message = createBaseError()
    message.cause = object.cause ?? ''
    return message
  },
}

function createBaseIdentify(): Identify {
  return { uri: '' }
}

export const Identify: MessageFns<Identify> = {
  encode(
    message: Identify,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.uri !== '') {
      writer.uint32(10).string(message.uri)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Identify {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseIdentify()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.uri = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Identify {
    return { uri: isSet(object.uri) ? globalThis.String(object.uri) : '' }
  },

  toJSON(message: Identify): unknown {
    const obj: any = {}
    if (message.uri !== '') {
      obj.uri = message.uri
    }
    return obj
  },

  create<I extends Exact<DeepPartial<Identify>, I>>(base?: I): Identify {
    return Identify.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<Identify>, I>>(object: I): Identify {
    const message = createBaseIdentify()
    message.uri = object.uri ?? ''
    return message
  },
}

function createBaseProcessor(): Processor {
  return { uri: '', config: '', arguments: '' }
}

export const Processor: MessageFns<Processor> = {
  encode(
    message: Processor,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.uri !== '') {
      writer.uint32(10).string(message.uri)
    }
    if (message.config !== '') {
      writer.uint32(18).string(message.config)
    }
    if (message.arguments !== '') {
      writer.uint32(26).string(message.arguments)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Processor {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseProcessor()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.uri = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.config = reader.string()
          continue
        }
        case 3: {
          if (tag !== 26) {
            break
          }

          message.arguments = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Processor {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : '',
      config: isSet(object.config) ? globalThis.String(object.config) : '',
      arguments: isSet(object.arguments)
        ? globalThis.String(object.arguments)
        : '',
    }
  },

  toJSON(message: Processor): unknown {
    const obj: any = {}
    if (message.uri !== '') {
      obj.uri = message.uri
    }
    if (message.config !== '') {
      obj.config = message.config
    }
    if (message.arguments !== '') {
      obj.arguments = message.arguments
    }
    return obj
  },

  create<I extends Exact<DeepPartial<Processor>, I>>(base?: I): Processor {
    return Processor.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<Processor>, I>>(
    object: I,
  ): Processor {
    const message = createBaseProcessor()
    message.uri = object.uri ?? ''
    message.config = object.config ?? ''
    message.arguments = object.arguments ?? ''
    return message
  },
}

function createBaseProcessorInit(): ProcessorInit {
  return { uri: '', error: undefined }
}

export const ProcessorInit: MessageFns<ProcessorInit> = {
  encode(
    message: ProcessorInit,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.uri !== '') {
      writer.uint32(10).string(message.uri)
    }
    if (message.error !== undefined) {
      Error.encode(message.error, writer.uint32(18).fork()).join()
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessorInit {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseProcessorInit()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.uri = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.error = Error.decode(reader, reader.uint32())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): ProcessorInit {
    return {
      uri: isSet(object.uri) ? globalThis.String(object.uri) : '',
      error: isSet(object.error) ? Error.fromJSON(object.error) : undefined,
    }
  },

  toJSON(message: ProcessorInit): unknown {
    const obj: any = {}
    if (message.uri !== '') {
      obj.uri = message.uri
    }
    if (message.error !== undefined) {
      obj.error = Error.toJSON(message.error)
    }
    return obj
  },

  create<I extends Exact<DeepPartial<ProcessorInit>, I>>(
    base?: I,
  ): ProcessorInit {
    return ProcessorInit.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<ProcessorInit>, I>>(
    object: I,
  ): ProcessorInit {
    const message = createBaseProcessorInit()
    message.uri = object.uri ?? ''
    message.error =
      object.error !== undefined && object.error !== null
        ? Error.fromPartial(object.error)
        : undefined
    return message
  },
}

function createBaseClose(): Close {
  return { channel: '' }
}

export const Close: MessageFns<Close> = {
  encode(
    message: Close,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.channel !== '') {
      writer.uint32(10).string(message.channel)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Close {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseClose()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.channel = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Close {
    return {
      channel: isSet(object.channel) ? globalThis.String(object.channel) : '',
    }
  },

  toJSON(message: Close): unknown {
    const obj: any = {}
    if (message.channel !== '') {
      obj.channel = message.channel
    }
    return obj
  },

  create<I extends Exact<DeepPartial<Close>, I>>(base?: I): Close {
    return Close.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<Close>, I>>(object: I): Close {
    const message = createBaseClose()
    message.channel = object.channel ?? ''
    return message
  },
}

function createBaseMessage(): Message {
  return { channel: '', data: '' }
}

export const Message: MessageFns<Message> = {
  encode(
    message: Message,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.channel !== '') {
      writer.uint32(10).string(message.channel)
    }
    if (message.data !== '') {
      writer.uint32(18).string(message.data)
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Message {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseMessage()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.channel = reader.string()
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.data = reader.string()
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): Message {
    return {
      channel: isSet(object.channel) ? globalThis.String(object.channel) : '',
      data: isSet(object.data) ? globalThis.String(object.data) : '',
    }
  },

  toJSON(message: Message): unknown {
    const obj: any = {}
    if (message.channel !== '') {
      obj.channel = message.channel
    }
    if (message.data !== '') {
      obj.data = message.data
    }
    return obj
  },

  create<I extends Exact<DeepPartial<Message>, I>>(base?: I): Message {
    return Message.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<Message>, I>>(object: I): Message {
    const message = createBaseMessage()
    message.channel = object.channel ?? ''
    message.data = object.data ?? ''
    return message
  },
}

function createBaseRunnerMessage(): RunnerMessage {
  return { proc: undefined, start: undefined, msg: undefined, close: undefined }
}

export const RunnerMessage: MessageFns<RunnerMessage> = {
  encode(
    message: RunnerMessage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.proc !== undefined) {
      Processor.encode(message.proc, writer.uint32(10).fork()).join()
    }
    if (message.start !== undefined) {
      Empty.encode(message.start, writer.uint32(18).fork()).join()
    }
    if (message.msg !== undefined) {
      Message.encode(message.msg, writer.uint32(26).fork()).join()
    }
    if (message.close !== undefined) {
      Close.encode(message.close, writer.uint32(34).fork()).join()
    }
    return writer
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RunnerMessage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseRunnerMessage()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.proc = Processor.decode(reader, reader.uint32())
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.start = Empty.decode(reader, reader.uint32())
          continue
        }
        case 3: {
          if (tag !== 26) {
            break
          }

          message.msg = Message.decode(reader, reader.uint32())
          continue
        }
        case 4: {
          if (tag !== 34) {
            break
          }

          message.close = Close.decode(reader, reader.uint32())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): RunnerMessage {
    return {
      proc: isSet(object.proc) ? Processor.fromJSON(object.proc) : undefined,
      start: isSet(object.start) ? Empty.fromJSON(object.start) : undefined,
      msg: isSet(object.msg) ? Message.fromJSON(object.msg) : undefined,
      close: isSet(object.close) ? Close.fromJSON(object.close) : undefined,
    }
  },

  toJSON(message: RunnerMessage): unknown {
    const obj: any = {}
    if (message.proc !== undefined) {
      obj.proc = Processor.toJSON(message.proc)
    }
    if (message.start !== undefined) {
      obj.start = Empty.toJSON(message.start)
    }
    if (message.msg !== undefined) {
      obj.msg = Message.toJSON(message.msg)
    }
    if (message.close !== undefined) {
      obj.close = Close.toJSON(message.close)
    }
    return obj
  },

  create<I extends Exact<DeepPartial<RunnerMessage>, I>>(
    base?: I,
  ): RunnerMessage {
    return RunnerMessage.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<RunnerMessage>, I>>(
    object: I,
  ): RunnerMessage {
    const message = createBaseRunnerMessage()
    message.proc =
      object.proc !== undefined && object.proc !== null
        ? Processor.fromPartial(object.proc)
        : undefined
    message.start =
      object.start !== undefined && object.start !== null
        ? Empty.fromPartial(object.start)
        : undefined
    message.msg =
      object.msg !== undefined && object.msg !== null
        ? Message.fromPartial(object.msg)
        : undefined
    message.close =
      object.close !== undefined && object.close !== null
        ? Close.fromPartial(object.close)
        : undefined
    return message
  },
}

function createBaseOrchestratorMessage(): OrchestratorMessage {
  return {
    init: undefined,
    msg: undefined,
    close: undefined,
    identify: undefined,
  }
}

export const OrchestratorMessage: MessageFns<OrchestratorMessage> = {
  encode(
    message: OrchestratorMessage,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.init !== undefined) {
      ProcessorInit.encode(message.init, writer.uint32(10).fork()).join()
    }
    if (message.msg !== undefined) {
      Message.encode(message.msg, writer.uint32(18).fork()).join()
    }
    if (message.close !== undefined) {
      Close.encode(message.close, writer.uint32(26).fork()).join()
    }
    if (message.identify !== undefined) {
      Identify.encode(message.identify, writer.uint32(34).fork()).join()
    }
    return writer
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number,
  ): OrchestratorMessage {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input)
    let end = length === undefined ? reader.len : reader.pos + length
    const message = createBaseOrchestratorMessage()
    while (reader.pos < end) {
      const tag = reader.uint32()
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break
          }

          message.init = ProcessorInit.decode(reader, reader.uint32())
          continue
        }
        case 2: {
          if (tag !== 18) {
            break
          }

          message.msg = Message.decode(reader, reader.uint32())
          continue
        }
        case 3: {
          if (tag !== 26) {
            break
          }

          message.close = Close.decode(reader, reader.uint32())
          continue
        }
        case 4: {
          if (tag !== 34) {
            break
          }

          message.identify = Identify.decode(reader, reader.uint32())
          continue
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break
      }
      reader.skip(tag & 7)
    }
    return message
  },

  fromJSON(object: any): OrchestratorMessage {
    return {
      init: isSet(object.init)
        ? ProcessorInit.fromJSON(object.init)
        : undefined,
      msg: isSet(object.msg) ? Message.fromJSON(object.msg) : undefined,
      close: isSet(object.close) ? Close.fromJSON(object.close) : undefined,
      identify: isSet(object.identify)
        ? Identify.fromJSON(object.identify)
        : undefined,
    }
  },

  toJSON(message: OrchestratorMessage): unknown {
    const obj: any = {}
    if (message.init !== undefined) {
      obj.init = ProcessorInit.toJSON(message.init)
    }
    if (message.msg !== undefined) {
      obj.msg = Message.toJSON(message.msg)
    }
    if (message.close !== undefined) {
      obj.close = Close.toJSON(message.close)
    }
    if (message.identify !== undefined) {
      obj.identify = Identify.toJSON(message.identify)
    }
    return obj
  },

  create<I extends Exact<DeepPartial<OrchestratorMessage>, I>>(
    base?: I,
  ): OrchestratorMessage {
    return OrchestratorMessage.fromPartial(base ?? ({} as any))
  },
  fromPartial<I extends Exact<DeepPartial<OrchestratorMessage>, I>>(
    object: I,
  ): OrchestratorMessage {
    const message = createBaseOrchestratorMessage()
    message.init =
      object.init !== undefined && object.init !== null
        ? ProcessorInit.fromPartial(object.init)
        : undefined
    message.msg =
      object.msg !== undefined && object.msg !== null
        ? Message.fromPartial(object.msg)
        : undefined
    message.close =
      object.close !== undefined && object.close !== null
        ? Close.fromPartial(object.close)
        : undefined
    message.identify =
      object.identify !== undefined && object.identify !== null
        ? Identify.fromPartial(object.identify)
        : undefined
    return message
  },
}

export type RunnerService = typeof RunnerService
export const RunnerService = {
  connect: {
    path: '/mypackage.Runner/connect',
    requestStream: true,
    responseStream: true,
    requestSerialize: (value: OrchestratorMessage) =>
      Buffer.from(OrchestratorMessage.encode(value).finish()),
    requestDeserialize: (value: Buffer) => OrchestratorMessage.decode(value),
    responseSerialize: (value: RunnerMessage) =>
      Buffer.from(RunnerMessage.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RunnerMessage.decode(value),
  },
} as const

export interface RunnerServer extends UntypedServiceImplementation {
  connect: handleBidiStreamingCall<OrchestratorMessage, RunnerMessage>
}

export interface RunnerClient extends Client {
  connect(): ClientDuplexStream<OrchestratorMessage, RunnerMessage>
  connect(
    options: Partial<CallOptions>,
  ): ClientDuplexStream<OrchestratorMessage, RunnerMessage>
  connect(
    metadata: Metadata,
    options?: Partial<CallOptions>,
  ): ClientDuplexStream<OrchestratorMessage, RunnerMessage>
}

export const RunnerClient = makeGenericClientConstructor(
  RunnerService,
  'mypackage.Runner',
) as unknown as {
  new (
    address: string,
    credentials: ChannelCredentials,
    options?: Partial<ClientOptions>,
  ): RunnerClient
  service: typeof RunnerService
  serviceName: string
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>

type KeysOfUnion<T> = T extends T ? keyof T : never
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never
    }

function isSet(value: any): boolean {
  return value !== null && value !== undefined
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter
  decode(input: BinaryReader | Uint8Array, length?: number): T
  fromJSON(object: any): T
  toJSON(message: T): unknown
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T
}
